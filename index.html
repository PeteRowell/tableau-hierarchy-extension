<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Hierarchy Tree Drill Down</title>
    
    <script>
        // Try multiple CDN sources - Tableau may block some when extension loads in iframe
        var sources = [
            'https://cdn.online.tableau.com/extensions/1.12.0/tableau.extensions.1.12.0.min.js',
            'https://extension.tableau.com/javascripts/extensions-api/tableau.extensions.1.latest.min.js',
            'https://cdn.jsdelivr.net/gh/tableau/extensions-api@1.12.0/lib/tableau.extensions.1.12.0.min.js'
        ];
        function loadScript(i) {
            if (i >= sources.length) return;
            var s = document.createElement('script');
            s.src = sources[i];
            s.onload = function() { if (typeof tableau !== 'undefined') document.dispatchEvent(new Event('tableau-loaded')); };
            s.onerror = function() { loadScript(i + 1); };
            document.head.appendChild(s);
        }
        loadScript(0);
    </script>
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: white; overflow: hidden; }
        #container { width: 100%; height: 100vh; display: flex; flex-direction: column; background: white; }
        #table-wrapper { flex: 1; overflow: auto; background: white; }
        #data-table { width: 100%; border-collapse: collapse; }
        #data-table thead { background: #f1f3f5; position: sticky; top: 0; z-index: 10; }
        #data-table th { padding: 10px 12px; text-align: left; font-weight: 600; color: #495057; border-bottom: 2px solid #dee2e6; font-size: 12px; white-space: nowrap; }
        #data-table th.measure-header { text-align: right; }
        #data-table td { padding: 8px 12px; border-bottom: 1px solid #f1f3f5; color: #212529; font-size: 13px; }
        #data-table tbody tr:hover { background: #f8f9fa; }
        .dimension-cell { cursor: pointer; user-select: none; white-space: nowrap; }
        .expandable { color: #1f77b4; font-weight: 500; }
        .expandable:hover { background: #e3f2fd; }
        .expand-icon { display: inline-block; width: 16px; margin-right: 4px; cursor: pointer; font-size: 10px; vertical-align: middle; }
        .measure-cell { text-align: right; font-variant-numeric: tabular-nums; cursor: pointer; }
        .child-row { display: none; }
        .child-row.visible { display: table-row; }
        #status { padding: 20px; text-align: center; color: #6c757d; font-size: 14px; }
        .loading { color: #1f77b4; }
        .error { color: #dc3545; background: #f8d7da; padding: 15px; border-radius: 4px; margin: 15px; }
    </style>
</head>
<body>
    <div id="container">
        <div id="table-wrapper">
            <div id="status" class="loading">Initializing extension...</div>
        </div>
    </div>

    <script>
        'use strict';

        let dataTable;
        let hierarchyFields = [];
        let measureFields = [];
        let treeData = [];
        let expandedNodes = new Set();

        const initTimeout = setTimeout(() => {
            showError('Initialization timed out. The extension requires Tableau 2024.2 or later.');
        }, 15000);

        function initDone() { clearTimeout(initTimeout); }

        function runInit() {
            if (typeof tableau === 'undefined') {
                showError('Tableau Extensions API failed to load from all CDN sources.');
                return;
            }
            tableau.extensions.initializeAsync().then(() => {
                initDone();
                if (!tableau.extensions.worksheetContent) {
                    showError('Worksheet extensions require Tableau 2024.2 or later.');
                    return;
                }
                loadData();
            }, (err) => {
                initDone();
                showError('Error initializing: ' + (err && err.message ? err.message : String(err)));
            });
        }

        document.addEventListener('tableau-loaded', runInit);
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof tableau !== 'undefined') runInit();
            else setTimeout(function() { if (typeof tableau !== 'undefined') runInit(); }, 500);
        });
        setTimeout(function() { if (typeof tableau === 'undefined') runInit(); }, 5000);

        async function loadData() {
            try {
                showStatus('Loading data...');
                const worksheet = tableau.extensions.worksheetContent.worksheet;
                let worksheetData;
                if (worksheet.getSummaryDataReaderAsync) {
                    const reader = await worksheet.getSummaryDataReaderAsync();
                    try { worksheetData = await reader.getAllPagesAsync(); }
                    finally { await reader.releaseAsync(); }
                } else {
                    worksheetData = await worksheet.getSummaryDataAsync();
                }
                dataTable = worksheetData;
                identifyFields(worksheetData.columns);
                if (hierarchyFields.length === 0) {
                    showError('No dimensional fields detected. Add dimensions to your worksheet.');
                    return;
                }
                buildTree();
                renderTable();
            } catch (err) {
                showError('Error loading data: ' + err.toString());
            }
        }

        function identifyFields(columns) {
            hierarchyFields = [];
            measureFields = [];
            columns.forEach(col => {
                if (['string', 'date', 'date-time', 'bool'].includes(col.dataType)) {
                    hierarchyFields.push({ name: col.fieldName, index: col.index });
                } else if (['int', 'float'].includes(col.dataType)) {
                    measureFields.push({ name: col.fieldName, index: col.index });
                }
            });
        }

        function buildTree() {
            treeData = [];
            if (hierarchyFields.length === 0) return;
            const rootMap = new Map();
            dataTable.data.forEach(row => {
                let currentMap = rootMap;
                let path = '';
                hierarchyFields.forEach((field, level) => {
                    const value = row[field.index].value;
                    const key = String(value);
                    path += (path ? '|' : '') + key;
                    if (!currentMap.has(key)) {
                        const node = { value, displayValue: String(value), level, path, children: new Map(), measures: {}, hasChildren: level < hierarchyFields.length - 1 };
                        measureFields.forEach(m => { node.measures[m.name] = 0; });
                        currentMap.set(key, node);
                    }
                    const node = currentMap.get(key);
                    measureFields.forEach(m => { node.measures[m.name] += parseFloat(row[m.index].value) || 0; });
                    currentMap = node.children;
                });
            });
            function mapToArray(map) {
                const arr = [];
                map.forEach((node, key) => arr.push({ ...node, children: mapToArray(node.children) }));
                return arr.sort((a, b) => String(a.value).localeCompare(String(b.value)));
            }
            treeData = mapToArray(rootMap);
        }

        function renderTable() {
            const tableWrapper = document.getElementById('table-wrapper');
            let html = '<table id="data-table"><thead><tr><th>Dimension</th>';
            measureFields.forEach(m => html += `<th class="measure-header">${escapeHtml(m.name)}</th>`);
            html += '</tr></thead><tbody>';
            function renderNode(node, parentPath = '') {
                const isExpanded = expandedNodes.has(node.path);
                const hasChildren = node.children && node.children.length > 0;
                const indent = '&nbsp;&nbsp;&nbsp;&nbsp;'.repeat(node.level);
                const rowClass = parentPath ? 'child-row' + (shouldShowRow(node.path) ? ' visible' : '') : '';
                const cellClass = hasChildren ? 'dimension-cell expandable' : 'dimension-cell';
                const icon = hasChildren ? (isExpanded ? '▼' : '▶') : '';
                html += `<tr class="${rowClass}" data-path="${node.path}">`;
                html += `<td class="${cellClass}" data-path="${node.path}" data-has-children="${hasChildren}">${indent}${icon ? '<span class="expand-icon">' + icon + '</span>' : ''}${escapeHtml(node.displayValue)}</td>`;
                measureFields.forEach(m => {
                    const val = node.measures[m.name] || 0;
                    const mc = hasChildren ? 'measure-cell expandable' : 'measure-cell';
                    html += `<td class="${mc}" data-path="${node.path}" data-has-children="${hasChildren}">${formatNumber(val)}</td>`;
                });
                html += '</tr>';
                if (hasChildren && node.children) node.children.forEach(c => renderNode(c, node.path));
            }
            treeData.forEach(node => renderNode(node));
            html += '</tbody></table>';
            tableWrapper.innerHTML = html;
            document.querySelectorAll('.dimension-cell, .measure-cell').forEach(cell => {
                cell.addEventListener('click', handleCellClick);
            });
        }

        function shouldShowRow(path) {
            const parts = path.split('|');
            for (let i = 1; i < parts.length; i++) {
                if (!expandedNodes.has(parts.slice(0, i).join('|'))) return false;
            }
            return true;
        }

        function handleCellClick(event) {
            const cell = event.currentTarget;
            const path = cell.dataset.path;
            if (cell.dataset.hasChildren !== 'true') return;
            if (expandedNodes.has(path)) {
                expandedNodes.delete(path);
                const toRemove = [];
                expandedNodes.forEach(p => { if (p.startsWith(path + '|')) toRemove.push(p); });
                toRemove.forEach(p => expandedNodes.delete(p));
            } else {
                expandedNodes.add(path);
            }
            renderTable();
        }

        function formatNumber(num) {
            if (num == null) return '-';
            return Number.isInteger(num) ? num.toLocaleString() : num.toLocaleString(undefined, { minimumFractionDigits: 0, maximumFractionDigits: 2 });
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function showStatus(msg) {
            document.getElementById('table-wrapper').innerHTML = `<div id="status" class="loading">${msg}</div>`;
        }

        function showError(msg) {
            document.getElementById('table-wrapper').innerHTML = `<div class="error">${msg}</div>`;
        }
    </script>
</body>
</html>
