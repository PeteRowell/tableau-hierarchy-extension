<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Hierarchy Tree Drill Down</title>
    
    <script src="https://cdn.online.tableau.com/extensions/1.10.0/tableau.extensions.1.10.0.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: white;
            overflow: hidden;
        }
        
        #container {
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background: white;
        }
        
        #table-wrapper {
            flex: 1;
            overflow: auto;
            background: white;
        }
        
        #data-table {
            width: 100%;
            border-collapse: collapse;
        }
        
        #data-table thead {
            background: #f1f3f5;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        #data-table th {
            padding: 10px 12px;
            text-align: left;
            font-weight: 600;
            color: #495057;
            border-bottom: 2px solid #dee2e6;
            font-size: 12px;
            white-space: nowrap;
        }
        
        #data-table th.measure-header {
            text-align: right;
        }
        
        #data-table td {
            padding: 8px 12px;
            border-bottom: 1px solid #f1f3f5;
            color: #212529;
            font-size: 13px;
        }
        
        #data-table tbody tr {
            transition: background-color 0.15s;
        }
        
        #data-table tbody tr:hover {
            background: #f8f9fa;
        }
        
        .dimension-cell {
            cursor: pointer;
            user-select: none;
            white-space: nowrap;
        }
        
        .expandable {
            color: #1f77b4;
            font-weight: 500;
        }
        
        .expandable:hover {
            color: #0d47a1;
            background: #e3f2fd;
        }
        
        .expand-icon {
            display: inline-block;
            width: 16px;
            height: 16px;
            margin-right: 4px;
            cursor: pointer;
            font-size: 10px;
            transition: transform 0.2s;
            vertical-align: middle;
        }
        
        .expand-icon.expanded {
            transform: rotate(90deg);
        }
        
        .indent {
            display: inline-block;
        }
        
        .measure-cell {
            text-align: right;
            font-variant-numeric: tabular-nums;
            cursor: pointer;
        }
        
        .measure-cell.expandable:hover {
            background: #e3f2fd;
        }
        
        .child-row {
            display: none;
        }
        
        .child-row.visible {
            display: table-row;
        }
        
        #status {
            padding: 20px;
            text-align: center;
            color: #6c757d;
            font-size: 14px;
        }
        
        .loading {
            color: #1f77b4;
        }
        
        .error {
            color: #dc3545;
            background: #f8d7da;
            padding: 15px;
            border-radius: 4px;
            margin: 15px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="table-wrapper">
            <div id="status" class="loading">Initializing extension...</div>
        </div>
    </div>

    <script>
        'use strict';

        let dataTable;
        let hierarchyFields = [];
        let measureFields = [];
        let treeData = [];
        let expandedNodes = new Set();

        // Add timeout to detect hanging initialization
        let initTimeout = setTimeout(() => {
            showError('Extension initialization timed out. This may indicate:<br>1. Worksheet has no data<br>2. No dimensions in the view<br>3. Extension API version mismatch<br><br>Make sure your worksheet has dimensions and measures.');
        }, 10000);

        tableau.extensions.initializeAsync({'configure': configure}).then(() => {
            clearTimeout(initTimeout);
            showStatus('Extension initialized. Loading data...');
            console.log('Viz Extension initialized');
            setTimeout(() => loadData(), 100);
        }, (err) => {
            clearTimeout(initTimeout);
            showError('Error initializing extension: ' + err.toString() + '<br><br>Details: ' + JSON.stringify(err));
            console.error('Init error:', err);
        });

        function configure() {
            console.log('Configure called');
        }

        async function loadData() {
            try {
                showStatus('Loading data from worksheet...');
                console.log('Starting data load...');
                
                if (!tableau.extensions.worksheetContent || !tableau.extensions.worksheetContent.worksheet) {
                    showError('Cannot access worksheet. Make sure this is loaded as a Viz Extension in a worksheet, not a dashboard.');
                    return;
                }
                
                showStatus('Fetching summary data...');
                const worksheetData = await tableau.extensions.worksheetContent.worksheet.getSummaryDataAsync();
                
                console.log('Data loaded:', worksheetData);
                console.log('Columns:', worksheetData.columns);
                console.log('Rows:', worksheetData.data.length);
                
                if (!worksheetData.data || worksheetData.data.length === 0) {
                    showError('No data found in worksheet. Please make sure your worksheet contains data.');
                    return;
                }
                
                dataTable = worksheetData;
                
                showStatus('Identifying hierarchy fields...');
                identifyFields(worksheetData.columns);
                
                if (hierarchyFields.length === 0) {
                    showError('No dimensional fields detected.<br><br>Please add at least one dimension (text, date, or hierarchy field) to your worksheet.<br><br>Found ' + worksheetData.columns.length + ' total columns.');
                    return;
                }
                
                console.log('Hierarchy fields:', hierarchyFields);
                console.log('Measure fields:', measureFields);
                
                showStatus('Building hierarchy tree...');
                buildTree();
                
                showStatus('Rendering table...');
                renderTable();
                
            } catch (err) {
                showError('Error loading data: ' + err.toString() + '<br><br>Stack: ' + (err.stack || 'No stack trace'));
                console.error('Load error:', err);
            }
        }

        function identifyFields(columns) {
            hierarchyFields = [];
            measureFields = [];
            
            columns.forEach(col => {
                console.log('Column:', col.fieldName, 'Type:', col.dataType);
                
                if (col.dataType === 'string' || 
                    col.dataType === 'date' || 
                    col.dataType === 'date-time' ||
                    col.dataType === 'bool') {
                    hierarchyFields.push({
                        name: col.fieldName,
                        index: col.index
                    });
                }
                else if (col.dataType === 'int' || col.dataType === 'float') {
                    measureFields.push({
                        name: col.fieldName,
                        index: col.index
                    });
                }
            });
        }

        function buildTree() {
            treeData = [];
            
            if (hierarchyFields.length === 0) return;
            
            // Build hierarchical structure
            const rootMap = new Map();
            
            dataTable.data.forEach(row => {
                let currentMap = rootMap;
                let path = '';
                
                hierarchyFields.forEach((field, level) => {
                    const value = row[field.index].value;
                    const key = String(value);
                    path += (path ? '|' : '') + key;
                    
                    if (!currentMap.has(key)) {
                        const node = {
                            value: value,
                            displayValue: String(value),
                            level: level,
                            path: path,
                            children: new Map(),
                            measures: {},
                            hasChildren: level < hierarchyFields.length - 1
                        };
                        
                        measureFields.forEach(measure => {
                            node.measures[measure.name] = 0;
                        });
                        
                        currentMap.set(key, node);
                    }
                    
                    const node = currentMap.get(key);
                    
                    // Add measure values
                    measureFields.forEach(measure => {
                        const val = parseFloat(row[measure.index].value) || 0;
                        node.measures[measure.name] += val;
                    });
                    
                    currentMap = node.children;
                });
            });
            
            // Convert to array
            function mapToArray(map) {
                const arr = [];
                map.forEach((node, key) => {
                    const children = mapToArray(node.children);
                    arr.push({
                        ...node,
                        children: children
                    });
                });
                
                arr.sort((a, b) => {
                    return String(a.value).localeCompare(String(b.value));
                });
                
                return arr;
            }
            
            treeData = mapToArray(rootMap);
            console.log('Tree built:', treeData);
        }

        function renderTable() {
            const tableWrapper = document.getElementById('table-wrapper');
            
            let html = '<table id="data-table"><thead><tr>';
            html += '<th>Dimension</th>';
            
            measureFields.forEach(measure => {
                html += `<th class="measure-header">${escapeHtml(measure.name)}</th>`;
            });
            
            html += '</tr></thead><tbody>';
            
            function renderNode(node, parentPath = '') {
                const isExpanded = expandedNodes.has(node.path);
                const hasChildren = node.children && node.children.length > 0;
                const indent = '&nbsp;&nbsp;&nbsp;&nbsp;'.repeat(node.level);
                
                let expandIcon = '';
                if (hasChildren) {
                    expandIcon = isExpanded ? '▼' : '▶';
                }
                
                const rowClass = parentPath ? 'child-row' + (shouldShowRow(node.path) ? ' visible' : '') : '';
                const cellClass = hasChildren ? 'dimension-cell expandable' : 'dimension-cell';
                
                html += `<tr class="${rowClass}" data-path="${node.path}">`;
                html += `<td class="${cellClass}" data-path="${node.path}" data-has-children="${hasChildren}">`;
                html += indent;
                if (expandIcon) {
                    html += `<span class="expand-icon ${isExpanded ? 'expanded' : ''}">${expandIcon}</span>`;
                }
                html += escapeHtml(node.displayValue);
                html += '</td>';
                
                measureFields.forEach(measure => {
                    const value = node.measures[measure.name] || 0;
                    const measureClass = hasChildren ? 'measure-cell expandable' : 'measure-cell';
                    html += `<td class="${measureClass}" data-path="${node.path}" data-has-children="${hasChildren}">${formatNumber(value)}</td>`;
                });
                
                html += '</tr>';
                
                if (hasChildren && node.children) {
                    node.children.forEach(child => {
                        renderNode(child, node.path);
                    });
                }
            }
            
            treeData.forEach(node => renderNode(node));
            
            html += '</tbody></table>';
            tableWrapper.innerHTML = html;
            
            // Add click handlers
            document.querySelectorAll('.dimension-cell, .measure-cell').forEach(cell => {
                cell.addEventListener('click', handleCellClick);
            });
        }

        function shouldShowRow(path) {
            const parts = path.split('|');
            for (let i = 1; i < parts.length; i++) {
                const parentPath = parts.slice(0, i).join('|');
                if (!expandedNodes.has(parentPath)) {
                    return false;
                }
            }
            return true;
        }

        function handleCellClick(event) {
            const cell = event.currentTarget;
            const path = cell.dataset.path;
            const hasChildren = cell.dataset.hasChildren === 'true';
            
            if (!hasChildren) return;
            
            if (expandedNodes.has(path)) {
                expandedNodes.delete(path);
                collapseChildren(path);
            } else {
                expandedNodes.add(path);
            }
            
            renderTable();
        }

        function collapseChildren(path) {
            const toRemove = [];
            expandedNodes.forEach(expandedPath => {
                if (expandedPath.startsWith(path + '|')) {
                    toRemove.push(expandedPath);
                }
            });
            toRemove.forEach(p => expandedNodes.delete(p));
        }

        function formatNumber(num) {
            if (num === null || num === undefined) return '-';
            if (Number.isInteger(num)) return num.toLocaleString();
            return num.toLocaleString(undefined, { 
                minimumFractionDigits: 0,
                maximumFractionDigits: 2 
            });
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function showStatus(message) {
            const tableWrapper = document.getElementById('table-wrapper');
            tableWrapper.innerHTML = `<div id="status" class="loading">${message}</div>`;
        }

        function showError(message) {
            const tableWrapper = document.getElementById('table-wrapper');
            tableWrapper.innerHTML = `<div class="error">${message}</div>`;
            console.error(message);
        }
    </script>
</body>
</html>
