<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Hierarchy Drill Down</title>
    
    <!-- Tableau Extensions API -->
    <script src="https://cdn.online.tableau.com/extensions/1.10.0/tableau.extensions.1.10.0.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            padding: 15px;
            background: #f8f9fa;
        }
        
        #container {
            max-width: 100%;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        #breadcrumb {
            padding: 12px 15px;
            background: #f1f3f5;
            border-bottom: 1px solid #dee2e6;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .breadcrumb-item {
            color: #495057;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .breadcrumb-link {
            color: #007bff;
            cursor: pointer;
            text-decoration: none;
            transition: color 0.2s;
        }
        
        .breadcrumb-link:hover {
            color: #0056b3;
            text-decoration: underline;
        }
        
        .breadcrumb-separator {
            color: #adb5bd;
        }
        
        #data-table {
            width: 100%;
            border-collapse: collapse;
        }
        
        #data-table thead {
            background: #e9ecef;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        #data-table th {
            padding: 12px 15px;
            text-align: left;
            font-weight: 600;
            color: #495057;
            border-bottom: 2px solid #dee2e6;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        #data-table td {
            padding: 12px 15px;
            border-bottom: 1px solid #f1f3f5;
            color: #212529;
        }
        
        #data-table tbody tr {
            transition: background-color 0.15s;
        }
        
        #data-table tbody tr:hover {
            background: #f8f9fa;
        }
        
        .drillable-cell {
            cursor: pointer;
            color: #007bff;
            font-weight: 500;
            position: relative;
            padding-left: 20px;
        }
        
        .drillable-cell:before {
            content: '▶';
            position: absolute;
            left: 5px;
            font-size: 10px;
            transition: transform 0.2s;
        }
        
        .drillable-cell:hover {
            color: #0056b3;
            text-decoration: underline;
        }
        
        .drillable-cell:hover:before {
            transform: translateX(2px);
        }
        
        #status {
            padding: 15px;
            text-align: center;
            color: #6c757d;
            font-size: 14px;
        }
        
        .loading {
            color: #007bff;
        }
        
        .error {
            color: #dc3545;
            background: #f8d7da;
            padding: 15px;
            border-radius: 4px;
            margin: 15px;
        }
        
        #table-wrapper {
            max-height: calc(100vh - 100px);
            overflow: auto;
        }
        
        .reset-button {
            background: #6c757d;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
        }
        
        .reset-button:hover {
            background: #5a6268;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="breadcrumb">
            <span class="breadcrumb-item">
                <span class="breadcrumb-link" id="reset-all">All Data</span>
            </span>
        </div>
        <div id="table-wrapper">
            <div id="status" class="loading">Initializing extension...</div>
        </div>
    </div>

    <script>
        'use strict';

        let worksheet;
        let hierarchyFields = [];
        let currentLevel = 0;
        let drillPath = [];
        let allData = [];

        // Initialize the extension
        tableau.extensions.initializeAsync().then(() => {
            console.log('Extension initialized');
            
            // Get the worksheet
            const dashboardName = tableau.extensions.dashboardContent.dashboard.name;
            const worksheets = tableau.extensions.dashboardContent.dashboard.worksheets;
            
            // Use the first worksheet or let user configure
            if (worksheets.length > 0) {
                worksheet = worksheets[0];
                loadData();
            } else {
                showError('No worksheets found in dashboard');
            }
        }, (err) => {
            showError('Error initializing extension: ' + err.toString());
        });

        async function loadData() {
            try {
                showStatus('Loading data...');
                
                // Get the data source
                const dataTable = await worksheet.getSummaryDataAsync();
                
                // Identify hierarchy fields
                identifyHierarchies(dataTable.columns);
                
                if (hierarchyFields.length === 0) {
                    showError('No hierarchies detected. Please add hierarchical fields to your view.');
                    return;
                }
                
                console.log('Hierarchy fields:', hierarchyFields);
                
                // Store all data
                allData = dataTable;
                
                // Display data at current level
                displayData(dataTable, currentLevel);
                
            } catch (err) {
                showError('Error loading data: ' + err.toString());
            }
        }

        function identifyHierarchies(columns) {
            hierarchyFields = [];
            
            // Look for fields that form a hierarchy
            // Tableau hierarchies often have similar naming patterns or are marked as hierarchical
            // We'll detect them by looking for related fields or let all dimensions be drillable
            
            const dimensionFields = columns.filter(col => 
                col.dataType === 'string' || 
                col.dataType === 'date' ||
                col.dataType === 'date-time'
            );
            
            // For this implementation, we'll treat all dimensions as potential hierarchy levels
            // ordered by their position in the view
            hierarchyFields = dimensionFields.map(col => col.fieldName);
            
            console.log('Detected hierarchy fields:', hierarchyFields);
        }

        function displayData(dataTable, level) {
            const tableWrapper = document.getElementById('table-wrapper');
            
            if (!hierarchyFields || hierarchyFields.length === 0) {
                showError('No hierarchy fields available');
                return;
            }
            
            // Determine which fields to show
            const fieldsToShow = hierarchyFields.slice(0, level + 1);
            const measures = dataTable.columns.filter(col => 
                col.dataType === 'int' || 
                col.dataType === 'float'
            );
            
            // Filter data based on drill path
            let filteredData = dataTable.data;
            if (drillPath.length > 0) {
                filteredData = dataTable.data.filter(row => {
                    return drillPath.every((pathItem, idx) => {
                        const colIndex = dataTable.columns.findIndex(col => 
                            col.fieldName === hierarchyFields[idx]
                        );
                        return row[colIndex].value === pathItem.value;
                    });
                });
            }
            
            // Aggregate data by current level
            const aggregatedData = aggregateByLevel(filteredData, dataTable.columns, level);
            
            // Create table
            let html = '<table id="data-table"><thead><tr>';
            
            // Add hierarchy column header
            if (level < hierarchyFields.length) {
                html += `<th>${hierarchyFields[level]}</th>`;
            }
            
            // Add measure headers
            measures.forEach(measure => {
                html += `<th>${measure.fieldName}</th>`;
            });
            
            html += '</tr></thead><tbody>';
            
            // Add data rows
            aggregatedData.forEach(row => {
                html += '<tr>';
                
                // Add dimension value (drillable if not at deepest level)
                const isDrillable = level < hierarchyFields.length - 1;
                const cellClass = isDrillable ? 'drillable-cell' : '';
                const value = row.dimension;
                
                html += `<td class="${cellClass}" data-value="${value}" data-level="${level}">${value}</td>`;
                
                // Add measures
                measures.forEach(measure => {
                    const measureValue = row.measures[measure.fieldName] || 0;
                    html += `<td>${formatNumber(measureValue)}</td>`;
                });
                
                html += '</tr>';
            });
            
            html += '</tbody></table>';
            
            tableWrapper.innerHTML = html;
            
            // Add click handlers to drillable cells
            document.querySelectorAll('.drillable-cell').forEach(cell => {
                cell.addEventListener('click', handleDrillDown);
            });
            
            updateBreadcrumb();
        }

        function aggregateByLevel(data, columns, level) {
            const dimensionField = hierarchyFields[level];
            const dimIndex = columns.findIndex(col => col.fieldName === dimensionField);
            
            if (dimIndex === -1) return [];
            
            const measures = columns.filter(col => 
                col.dataType === 'int' || 
                col.dataType === 'float'
            );
            
            const aggregated = {};
            
            data.forEach(row => {
                const dimValue = row[dimIndex].value;
                
                if (!aggregated[dimValue]) {
                    aggregated[dimValue] = {
                        dimension: dimValue,
                        measures: {}
                    };
                    
                    measures.forEach(measure => {
                        aggregated[dimValue].measures[measure.fieldName] = 0;
                    });
                }
                
                // Sum measures
                measures.forEach(measure => {
                    const measureIndex = columns.findIndex(col => col.fieldName === measure.fieldName);
                    const value = parseFloat(row[measureIndex].value) || 0;
                    aggregated[dimValue].measures[measure.fieldName] += value;
                });
            });
            
            return Object.values(aggregated).sort((a, b) => 
                a.dimension.toString().localeCompare(b.dimension.toString())
            );
        }

        function handleDrillDown(event) {
            const cell = event.currentTarget;
            const value = cell.dataset.value;
            const level = parseInt(cell.dataset.level);
            
            // Add to drill path
            drillPath.push({
                field: hierarchyFields[level],
                value: value,
                level: level
            });
            
            currentLevel = level + 1;
            
            // Redisplay data
            displayData(allData, currentLevel);
        }

        function updateBreadcrumb() {
            const breadcrumb = document.getElementById('breadcrumb');
            let html = '<span class="breadcrumb-item"><span class="breadcrumb-link" id="reset-all">All Data</span></span>';
            
            drillPath.forEach((item, idx) => {
                html += '<span class="breadcrumb-separator">›</span>';
                html += `<span class="breadcrumb-item">`;
                html += `<span class="breadcrumb-link" data-level="${idx}">${item.value}</span>`;
                html += `</span>`;
            });
            
            breadcrumb.innerHTML = html;
            
            // Add click handlers
            document.getElementById('reset-all').addEventListener('click', resetDrill);
            
            document.querySelectorAll('.breadcrumb-link[data-level]').forEach(link => {
                link.addEventListener('click', (e) => {
                    const level = parseInt(e.target.dataset.level);
                    drillToLevel(level);
                });
            });
        }

        function resetDrill() {
            drillPath = [];
            currentLevel = 0;
            displayData(allData, currentLevel);
        }

        function drillToLevel(level) {
            drillPath = drillPath.slice(0, level + 1);
            currentLevel = level + 1;
            displayData(allData, currentLevel);
        }

        function formatNumber(num) {
            if (num === null || num === undefined) return '-';
            if (Number.isInteger(num)) return num.toLocaleString();
            return num.toLocaleString(undefined, { maximumFractionDigits: 2 });
        }

        function showStatus(message) {
            const tableWrapper = document.getElementById('table-wrapper');
            tableWrapper.innerHTML = `<div id="status" class="loading">${message}</div>`;
        }

        function showError(message) {
            const tableWrapper = document.getElementById('table-wrapper');
            tableWrapper.innerHTML = `<div class="error">${message}</div>`;
            console.error(message);
        }
    </script>
</body>
</html>
